<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Interface - Portfolio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        .dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-align: left;
            padding: 30px 50px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.95);
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            min-width: 400px;
        }
        
        .dialog.error {
            color: #ff0000;
            border-color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        
        .cursor {
            display: inline-block;
            width: 12px;
            height: 20px;
            background: #00ff00;
            margin-left: 5px;
            animation: blink 1s infinite;
        }
        
        .cursor.error {
            background: #ff0000;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        @keyframes glitch {
            0%, 100% {
                text-shadow: 0 0 10px currentColor;
                transform: translate(-50%, -50%);
            }
            20% {
                text-shadow: -2px 0 currentColor, 2px 0 #00ff00;
                transform: translate(-48%, -50%);
            }
            40% {
                text-shadow: 2px 0 currentColor, -2px 0 #0000ff;
                transform: translate(-52%, -50%);
            }
            60% {
                text-shadow: 0 0 10px currentColor;
                transform: translate(-50%, -48%);
            }
            80% {
                text-shadow: 1px 1px 0 #ff00ff, -1px -1px 0 #00ffff;
                transform: translate(-50%, -52%);
            }
        }
        
        .glitch-active {
            animation: glitch 0.3s infinite;
        }
        
        .typing-text {
            display: inline;
        }

        /* Terminal Styles */
        .terminal-window {
            width: 854px;
            height: 592px;
            background: rgba(10, 10, 10, 0.65);
            backdrop-filter: blur(5px);
            border: 1px solid #333;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            position: fixed;
            min-width: 400px;
            min-height: 300px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .terminal-window.visible {
            display: flex;
        }

        .terminal-window.focused {
            border-color: #555;
        }

        .terminal-header {
            background: rgba(26, 26, 26, 0.9);
            height: 32px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 12px;
            cursor: move;
            user-select: none;
        }

        .terminal-title {
            color: #888;
            font-size: 13px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            transition: color 0.2s;
        }

        .terminal-window.focused .terminal-title {
            color: #fff;
        }

        .terminal-controls {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #0a0a0a;
            font-weight: bold;
            transition: all 0.2s;
        }

        .terminal-window:not(.focused) .control-btn {
            background: #666 !important;
        }

        .control-btn:hover {
            opacity: 0.8;
        }

        .close-btn {
            background: #ff5f56;
        }

        .maximize-btn {
            background: #27c93f;
        }

        .terminal-body {
            flex: 1;
            background: rgba(10, 10, 10, 0.7);
            padding: 12px;
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;
        }

        .terminal-content {
            color: #00ff00;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            padding: 0;
        }

        .terminal-line {
            display: flex;
            align-items: baseline;
            min-height: 20px;
            margin: 0;
            padding: 0;
        }

        .prompt {
            color: #00ff00;
            margin-right: 5px;
            white-space: nowrap;
        }

        .terminal-input-wrapper {
            flex: 1;
            display: inline-flex;
            position: relative;
        }

        .terminal-input {
            background: transparent;
            border: none;
            outline: none;
            color: #00ff00;
            font-family: inherit;
            font-size: inherit;
            width: 100%;
            padding: 0;
            margin: 0;
            caret-color: transparent;
        }

        .terminal-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: #00ff00;
            animation: blink 1s infinite;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Scrollbar styling */
        .terminal-body::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-body::-webkit-scrollbar-track {
            background: rgba(10, 10, 10, 0.5);
        }

        .terminal-body::-webkit-scrollbar-thumb {
            background: rgba(51, 51, 51, 0.8);
            border-radius: 4px;
        }

        .terminal-body::-webkit-scrollbar-thumb:hover {
            background: rgba(68, 68, 68, 0.9);
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            background: transparent;
        }

        .resize-handle-n {
            top: 0;
            left: 10px;
            right: 10px;
            height: 5px;
            cursor: ns-resize;
        }

        .resize-handle-s {
            bottom: 0;
            left: 10px;
            right: 10px;
            height: 5px;
            cursor: ns-resize;
        }

        .resize-handle-e {
            top: 10px;
            right: 0;
            bottom: 10px;
            width: 5px;
            cursor: ew-resize;
        }

        .resize-handle-w {
            top: 10px;
            left: 0;
            bottom: 10px;
            width: 5px;
            cursor: ew-resize;
        }

        .resize-handle-ne {
            top: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: nesw-resize;
        }

        .resize-handle-nw {
            top: 0;
            left: 0;
            width: 10px;
            height: 10px;
            cursor: nwse-resize;
        }

        .resize-handle-se {
            bottom: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: nwse-resize;
        }

        .resize-handle-sw {
            bottom: 0;
            left: 0;
            width: 10px;
            height: 10px;
            cursor: nesw-resize;
        }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>
    
    <div id="rootDialog" class="dialog">
        <div id="typingText" class="typing-text"></div>
        <span id="cursor" class="cursor"></span>
        <div id="inputArea" style="display: none; margin-top: 20px;">
            <span style="color: #888;">root@matrix:~$ </span>
            <span id="userInput"></span>
            <span class="cursor"></span>
        </div>
    </div>

    <!-- Terminal Window -->
    <div class="terminal-window focused" id="terminal">
        <div class="terminal-header" id="terminal-header">
            <div class="terminal-title">Terminal - root@matrix</div>
            <div class="terminal-controls">
                <button class="control-btn maximize-btn" id="maximize-btn">⬜</button>
                <button class="control-btn close-btn" id="close-btn">✕</button>
            </div>
        </div>
        <div class="terminal-body" id="terminal-body">
            <div class="terminal-content" id="terminal-content">
                <div class="terminal-line" id="current-line">
                    <span class="prompt">root@matrix:~$</span>
                    <div class="terminal-input-wrapper">
                        <input type="text" class="terminal-input" id="terminal-input" autofocus>
                        <span class="terminal-cursor" id="terminal-cursor"></span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Resize handles -->
        <div class="resize-handle resize-handle-n" data-resize="n"></div>
        <div class="resize-handle resize-handle-s" data-resize="s"></div>
        <div class="resize-handle resize-handle-e" data-resize="e"></div>
        <div class="resize-handle resize-handle-w" data-resize="w"></div>
        <div class="resize-handle resize-handle-ne" data-resize="ne"></div>
        <div class="resize-handle resize-handle-nw" data-resize="nw"></div>
        <div class="resize-handle resize-handle-se" data-resize="se"></div>
        <div class="resize-handle resize-handle-sw" data-resize="sw"></div>
    </div>
    
    <script>
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        
        // Halbbreite Katakana (U+FF65 bis U+FF9F)
        const katakana = [];
        for (let i = 0xFF65; i <= 0xFF9F; i++) {
            katakana.push(String.fromCharCode(i));
        }
        
        // Canvas Setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Matrix-Konfiguration
        const fontSize = 20;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = new Array(columns).fill(0);
        const speeds = new Array(columns).fill(0).map(() => 0.1 + Math.random() * 0.3);
        const trails = new Array(columns).fill(0).map(() => 10 + Math.random() * 5);
        
        // Zeichen-Matrix für persistente Zeichen
        const charMatrix = new Array(columns).fill(null).map(() => []);
        
        // Zeichenfunktion
        function draw() {
            // Schwarzer Hintergrund ohne Transparenz
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grüne Zeichen
            ctx.font = fontSize + 'px monospace';
            
            for (let i = 0; i < drops.length; i++) {
                const currentRow = Math.floor(drops[i]);
                const y = currentRow * fontSize;
                
                if (!charMatrix[i][currentRow]) {
                    charMatrix[i][currentRow] = katakana[Math.floor(Math.random() * katakana.length)];
                }
                
                const trailLength = trails[i];
                
                for (let j = 0; j < trailLength; j++) {
                    const row = currentRow - j;
                    if (row >= 0 && charMatrix[i][row]) {
                        const charY = row * fontSize + fontSize;
                        
                        if (j === 0) {
                            ctx.fillStyle = '#0F0';
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#0F0';
                        } else {
                            const opacity = Math.max(0.1, 1 - (j / trailLength));
                            ctx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.fillText(charMatrix[i][row], i * fontSize, charY);
                    }
                }
                
                drops[i] += speeds[i];
                
                const maxRows = Math.ceil(canvas.height / fontSize);
                if (currentRow > maxRows + trailLength) {
                    drops[i] = 0;
                    speeds[i] = 0.1 + Math.random() * 0.3;
                    trails[i] = 10 + Math.random() * 5;
                    charMatrix[i] = [];
                }
            }
        }
        
        // Animation mit 30 FPS
        setInterval(draw, 33);
        
        // Dialog-System
        const rootDialog = document.getElementById('rootDialog');
        const typingTextEl = document.getElementById('typingText');
        const cursorEl = document.getElementById('cursor');
        const inputArea = document.getElementById('inputArea');
        const userInputEl = document.getElementById('userInput');
        
        let currentInput = '';
        let dialogActive = false;
        
        // Typing Animation
        function typeText(text, element, callback, speed = 80) {
            let i = 0;
            element.textContent = '';
            
            const typeInterval = setInterval(() => {
                element.textContent += text[i];
                i++;
                
                if (i >= text.length) {
                    clearInterval(typeInterval);
                    if (callback) callback();
                }
            }, speed);
        }
        
        // Dialog anzeigen
        function showRootDialog() {
            dialogActive = true;
            rootDialog.classList.add('glitch-active');
            
            // Cursor für Typing-Animation wieder anzeigen
            cursorEl.style.display = 'inline-block';
            
            // Fade in
            let opacity = 0;
            const fadeIn = setInterval(() => {
                opacity += 0.05;
                rootDialog.style.opacity = opacity;
                if (opacity >= 1) {
                    clearInterval(fadeIn);
                    
                    // Glitch für 500ms
                    setTimeout(() => {
                        rootDialog.classList.remove('glitch-active');
                        
                        // Text animiert eintippen
                        setTimeout(() => {
                            typeText('Do you want to continue as root? (y/n)', typingTextEl, () => {
                                // Ersten Cursor verstecken und Input-Bereich anzeigen
                                cursorEl.style.display = 'none';
                                inputArea.style.display = 'block';
                                rootDialog.style.pointerEvents = 'auto';
                            });
                        }, 500);
                    }, 500);
                }
            }, 20);
        }
        
        // Error Dialog
        function showErrorDialog() {
            rootDialog.classList.add('error');
            rootDialog.classList.add('glitch-active');
            cursorEl.classList.add('error');
            
            typingTextEl.textContent = '';
            inputArea.style.display = 'none';
            currentInput = '';
            userInputEl.textContent = '';
            
            typeText('ERROR: Permission Denied\nAccess Restricted', typingTextEl, () => {
                setTimeout(() => {
                    rootDialog.classList.remove('glitch-active');
                    
                    setTimeout(() => {
                        let fadeOpacity = 1;
                        const fadeOut = setInterval(() => {
                            fadeOpacity -= 0.05;
                            rootDialog.style.opacity = fadeOpacity;
                            if (fadeOpacity <= 0) {
                                clearInterval(fadeOut);
                                rootDialog.style.opacity = 0;
                                rootDialog.style.pointerEvents = 'none';
                                
                                // Dialog komplett zurücksetzen
                                setTimeout(() => {
                                    rootDialog.classList.remove('error');
                                    cursorEl.classList.remove('error');
                                    typingTextEl.textContent = '';
                                    inputArea.style.display = 'none';
                                    dialogActive = false;
                                    
                                    // Nach Pause neuen Dialog starten
                                    setTimeout(showRootDialog, 1000);
                                }, 100);
                            }
                        }, 20);
                    }, 2000);
                }, 1000);
            }, 50);
        }
        
        // Success - öffnet Terminal
        function handleSuccess() {
            typingTextEl.textContent = '';
            inputArea.style.display = 'none';
            
            typeText('Access Granted\nWelcome, root user\nInitializing terminal...', typingTextEl, () => {
                setTimeout(() => {
                    // Dialog ausblenden
                    let fadeOpacity = 1;
                    const fadeOut = setInterval(() => {
                        fadeOpacity -= 0.05;
                        rootDialog.style.opacity = fadeOpacity;
                        if (fadeOpacity <= 0) {
                            clearInterval(fadeOut);
                            rootDialog.style.opacity = 0;
                            rootDialog.style.pointerEvents = 'none';
                            
                            // Terminal anzeigen
                            openTerminal();
                        }
                    }, 20);
                }, 2000);
            }, 60);
        }
        
        // Terminal öffnen
        function openTerminal() {
            const terminal = document.getElementById('terminal');
            terminal.classList.add('visible');
            
            // Fade in Terminal
            setTimeout(() => {
                terminal.style.opacity = '1';
                const terminalInput = document.getElementById('terminal-input');
                if (terminalInput) {
                    terminalInput.focus();
                }
            }, 100);
        }
        
        // Keyboard Event Handler für Root Dialog
        document.addEventListener('keydown', (e) => {
            if (!dialogActive || inputArea.style.display === 'none') return;
            
            if (e.key === 'Enter') {
                const input = currentInput.toLowerCase().trim();
                
                if (input === 'y' || input === 'yes') {
                    handleSuccess();
                } else if (input === 'n' || input === 'no') {
                    showErrorDialog();
                } else {
                    // Ungültige Eingabe - Input zurücksetzen
                    currentInput = '';
                    userInputEl.textContent = '';
                }
            } else if (e.key === 'Backspace') {
                currentInput = currentInput.slice(0, -1);
                userInputEl.textContent = currentInput;
            } else if (e.key.length === 1 && /[yn]/i.test(e.key)) {
                // Nur y, n, Y, N erlauben
                currentInput += e.key;
                userInputEl.textContent = currentInput;
            }
            
            e.preventDefault();
        });
        
        // Initial Dialog nach 5 Sekunden
        setTimeout(showRootDialog, 5000);

        // Terminal Functionality
        const terminal = document.getElementById('terminal');
        const terminalHeader = document.getElementById('terminal-header');
        const terminalBody = document.getElementById('terminal-body');
        const terminalContent = document.getElementById('terminal-content');
        let terminalInput = document.getElementById('terminal-input');
        let terminalCursor = document.getElementById('terminal-cursor');
        const closeBtn = document.getElementById('close-btn');
        const maximizeBtn = document.getElementById('maximize-btn');

        let isDragging = false;
        let isResizing = false;
        let isMaximized = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        let previousSize = { width: '854px', height: '592px', top: '50%', left: '50%', transform: 'translate(-50%, -50%)' };
        let resizeDirection = '';
        let startWidth;
        let startHeight;
        let startX;
        let startY;
        let startLeft;
        let startTop;

        // Command history
        const commandHistory = [];
        let historyIndex = -1;

        // Window focus handling
        document.addEventListener('click', (e) => {
            if (terminal.contains(e.target)) {
                terminal.classList.add('focused');
                if (terminalInput) {
                    terminalInput.focus();
                }
            } else {
                terminal.classList.remove('focused');
            }
        });

        // Focus input when clicking in terminal body
        terminalBody.addEventListener('click', (e) => {
            e.stopPropagation();
            terminal.classList.add('focused');
            if (terminalInput) {
                terminalInput.focus();
            }
        });

        // Update cursor position
        function updateTerminalCursorPosition() {
            if (!terminalInput || !terminalCursor) return;
            
            const inputValue = terminalInput.value;
            const textWidth = getTextWidth(inputValue, getComputedStyle(terminalInput));
            terminalCursor.style.left = textWidth + 'px';
        }

        function getTextWidth(text, style) {
            const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
            const context = canvas.getContext("2d");
            context.font = style.font || `${style.fontSize} ${style.fontFamily}`;
            return context.measureText(text).width;
        }

        // Handle terminal input
        function handleTerminalInput(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const command = terminalInput.value.trim();
                
                // Get current line
                const currentLine = terminalInput.closest('.terminal-line');
                
                // Create output line with command
                const outputLine = document.createElement('div');
                outputLine.className = 'terminal-line';
                outputLine.innerHTML = `<span class="prompt">root@matrix:~$</span><span>${command}</span>`;
                
                // Replace current line with output
                currentLine.replaceWith(outputLine);
                
                // Process command
                if (command !== '') {
                    commandHistory.push(command);
                    historyIndex = commandHistory.length;
                    
                    if (command.toLowerCase() === 'clear') {
                        terminalContent.innerHTML = '';
                    }
                }
                
                // Create new input line
                const newLine = document.createElement('div');
                newLine.className = 'terminal-line';
                newLine.innerHTML = `
                    <span class="prompt">root@matrix:~$</span>
                    <div class="terminal-input-wrapper">
                        <input type="text" class="terminal-input" id="new-terminal-input" autofocus>
                        <span class="terminal-cursor" id="new-terminal-cursor"></span>
                    </div>
                `;
                terminalContent.appendChild(newLine);
                
                // Update references
                terminalInput = document.getElementById('new-terminal-input');
                terminalCursor = document.getElementById('new-terminal-cursor');
                
                // Add event listeners to new input
                terminalInput.addEventListener('keydown', handleTerminalInput);
                terminalInput.addEventListener('input', updateTerminalCursorPosition);
                terminalInput.focus();
                
                // Give IDs back
                terminalInput.id = 'terminal-input';
                terminalCursor.id = 'terminal-cursor';
                
                // Scroll to bottom
                terminalBody.scrollTop = terminalBody.scrollHeight;
            }
        }

        // Initial event listeners for terminal
        terminalInput.addEventListener('keydown', handleTerminalInput);
        terminalInput.addEventListener('input', updateTerminalCursorPosition);

        // Dragging functionality
        function dragStart(e) {
            if (isMaximized) return;
            
            const rect = terminal.getBoundingClientRect();
            initialX = e.clientX - rect.left;
            initialY = e.clientY - rect.top;

            if (e.target === terminalHeader) {
                isDragging = true;
            }
        }

        function dragEnd(e) {
            isDragging = false;
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                terminal.style.left = (e.clientX - initialX) + 'px';
                terminal.style.top = (e.clientY - initialY) + 'px';
                terminal.style.transform = 'none';
            }
        }

        // Close button
        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            terminal.style.opacity = '0';
            setTimeout(() => {
                terminal.classList.remove('visible');
                terminal.style.display = 'none';
            }, 500);
        });

        // Maximize button
        maximizeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!isMaximized) {
                previousSize = {
                    width: terminal.style.width || '854px',
                    height: terminal.style.height || '592px',
                    top: terminal.style.top,
                    left: terminal.style.left,
                    transform: terminal.style.transform
                };
                
                terminal.style.width = '100vw';
                terminal.style.height = '100vh';
                terminal.style.top = '0';
                terminal.style.left = '0';
                terminal.style.transform = 'none';
                isMaximized = true;
            } else {
                terminal.style.width = previousSize.width;
                terminal.style.height = previousSize.height;
                terminal.style.top = previousSize.top;
                terminal.style.left = previousSize.left;
                terminal.style.transform = previousSize.transform;
                isMaximized = false;
            }
        });

        // Resize functionality
        const resizeHandles = document.querySelectorAll('.resize-handle');
        
        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                if (isMaximized) return;
                
                isResizing = true;
                resizeDirection = handle.getAttribute('data-resize');
                
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = terminal.getBoundingClientRect();
                startWidth = rect.width;
                startHeight = rect.height;
                startLeft = rect.left;
                startTop = rect.top;
                
                e.preventDefault();
                e.stopPropagation();
            });
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            
            let newWidth = startWidth;
            let newHeight = startHeight;
            let newLeft = startLeft;
            let newTop = startTop;
            
            if (resizeDirection.includes('e')) {
                newWidth = startWidth + dx;
            }
            if (resizeDirection.includes('w')) {
                newWidth = startWidth - dx;
                newLeft = startLeft + dx;
            }
            if (resizeDirection.includes('s')) {
                newHeight = startHeight + dy;
            }
            if (resizeDirection.includes('n')) {
                newHeight = startHeight - dy;
                newTop = startTop + dy;
            }
            
            // Apply minimum size constraints
            if (newWidth >= 400) {
                terminal.style.width = newWidth + 'px';
                if (resizeDirection.includes('w')) {
                    terminal.style.left = newLeft + 'px';
                }
            }
            if (newHeight >= 300) {
                terminal.style.height = newHeight + 'px';
                if (resizeDirection.includes('n')) {
                    terminal.style.top = newTop + 'px';
                }
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            resizeDirection = '';
        });

        // Mouse events for terminal
        terminalHeader.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
    </script>
</body>
</html>
